part of chronosgl;

abstract class Projection extends ShaderInputProvider {
  Projection(String name) : super(name);

  void Adjust(HTML.CanvasElement canvas,
      [double xscale = 1.0, double yscale = 1.0]) {
    final int w = (xscale * canvas.clientWidth).floor();
    final int h = (yscale * canvas.clientHeight).floor();
    SetAspect(w / h);
  }

  void SetAspect(double aspect);

  void SetAspectWH(int w, int h) {
    SetAspect(w / h);
  }
}

class Orthographic extends Projection {
  final Camera _camera;
  final VM.Matrix4 _proj = new VM.Matrix4.zero();
  final VM.Matrix4 _viewMatrix = new VM.Matrix4.zero();
  final VM.Matrix4 _projViewMatrix = new VM.Matrix4.identity();
  double _l;
  double _r;
  double _d;
  double _f;
  double _b;
  double _aspect = 1.0;

  // d = "down", up is computed dynamically based on height & width
  Orthographic(this._camera, this._l, this._r, this._d, this._f, this._b)
      : super("othrogrpahic") {
    Update();
  }

  void UpdateUniforms(ShaderProgramInputs inputs) {
    _camera.getViewMatrix(_viewMatrix);
    _projViewMatrix.setFrom(_proj);
    _projViewMatrix.multiply(_viewMatrix);
    inputs.SetUniformWithOrigin(this, uPerspectiveViewMatrix, _projViewMatrix);
  }

  void SetAspect(double aspect) {
    if (aspect == _aspect) return;
    _aspect = aspect;
    Update();
  }

  void Update() {
    double width = _r - _l;
    double height = width / _aspect;
    VM.setOrthographicMatrix(_proj, _l, _r, _d, _d + height, _f, _b);
  }
}

// very much like a orthographic
class ShadowProjection extends Projection {
  final Light _light;
  final VM.Matrix4 _proj = new VM.Matrix4.zero();
  final VM.Matrix4 _viewMatrix = new VM.Matrix4.zero();
  final VM.Matrix4 _projViewMatrix = new VM.Matrix4.identity();
  double _l;
  double _r;
  double _d;
  double _f;
  double _b;
  double _aspect = 1.0;

  // d = "down", up is computed dynamically based on height & width
  ShadowProjection(this._light, this._l, this._r, this._d, this._f, this._b)
      : super("shadow-projection") {
    Update();
  }

  void UpdateUniforms(ShaderProgramInputs inputs) {
    _light.getViewMatrixForShadow(_viewMatrix);
    _projViewMatrix.setFrom(_proj);
    _projViewMatrix.multiply(_viewMatrix);
    inputs.SetUniformWithOrigin(this, uPerspectiveViewMatrix, _projViewMatrix);
  }

  void SetAspect(double aspect) {
    if (aspect == _aspect) return;
    _aspect = aspect;
    Update();
  }

  void Update() {
    double width = _r - _l;
    double height = width / _aspect;
    VM.setOrthographicMatrix(_proj, _l, _r, _d, _d + height, _f, _b);
  }
}

class Perspective extends Projection {
  Camera _camera;
  double _fov = 50.0; // horizontal fov in deg  divided by 2

  double _near = 0.1;
  double _far = 1000.0;
  double _aspect = 1.0;
  final VM.Matrix4 _perspectiveViewMatrix = new VM.Matrix4.identity();
  final VM.Matrix4 _viewMatrix = new VM.Matrix4.identity();
  final VM.Matrix4 _mat = new VM.Matrix4.zero();

  Perspective(this._camera,
      [this._near = 0.1, this._far = 1000.0, String name = "perspective"])
      : super(name) {
    Update();
  }

  void Update() {
    print ("@@@@@@@update: ${_aspect}");
    VM.setPerspectiveMatrix(_mat, _fov * Math.PI / 180.0, _aspect, _near, _far);
  }

  void SetAspect(double aspect) {
    if (aspect == _aspect) return;
    _aspect = aspect;
    Update();
  }

  void UpdateFov(double fov) {
    if (fov == _fov) return;
    _fov = fov;
    Update();
  }

  void UpdateCamera(Camera cam) {
    _camera = cam;
  }

  void UpdateUniforms(ShaderProgramInputs inputs) {;
    inputs.SetUniformWithOrigin(this, uEyePosition, _camera.getEyePosition());
    _camera.getViewMatrix(_viewMatrix);
    _perspectiveViewMatrix.setFrom(_mat);
    _perspectiveViewMatrix.multiply(_viewMatrix);
    inputs.SetUniformWithOrigin(
        this, uPerspectiveViewMatrix, _perspectiveViewMatrix);
  }
}
